---
title: "Mapping Demo"
author: "Alex Lundry"
date: "2022-09-13"
output: github_document
---

There are several ways to create a map in R, and there is a great deal you can do with geo-spatial data in terms of geocomputation and spatial analysis.  BUT, those are incredibly dense subjects that take up entire degree programs in and of themselves, so we must be thoughtful about what we spend time on.  For the purposes of this course, we will focus on the construction of two types of maps: Choropleth maps and cartograms.  These are the two that you will most likely be called upon to create in the world of public policy.  

We'll rely upon several packages along the way:
```{r}
library(tidyverse)
library(maps)
```

We'll be using `ggplot2` for our map creation, but in order to do so, we need to reformat the `maps` data using the function `map_data()` from `ggplot2`.  

```{r}
world_map <- map_data(map = "world")
state_map <- map_data(map = "state")
va_state_map <- map_data(map = "state", region = "virginia")
county_map <- map_data(map = "county")
va_county_map <- map_data(map = "county", region = "virginia")
```

The `map_data()` function calls `map()` (a function from the `maps` library) and then reformats the returned data, converting it to a data frame.  Notice that the first argument is the `database = ` which specifies `usa, state, county, world` and others.  The `regions = ` argument can limit the map to certain regions.

Take a look at the data frame it generates:
```{r}
glimpse(state_map)
```

We have a stunning 15,537 rows!  Why?  Notice the columns available here, especially: long, lat, group and order.  Each row represents a specific point on the map (lat/long).  The group tells you what specific shape (state) it is a part of, and order tells you the order in which to draw lines (the border) from point to point. You need a lot of lines to draw a good-looking map!

### Map Boundaries

Here is an example for the polygon for the state of Virginia.  Remember how ggplot builds in layers.  Let's first just creat the plot, and then add a `geom_point` to reinforce how our data frame is just a series of locations that represent points along the border.
```{r}
va <- ggplot(va_state_map, aes(long, lat, group = group))

va +
   geom_point()
```

Now let's connect those lines to give us an actual border!
```{r}
va +
   geom_point() +
   geom_path(color = "blue")
```

Notice is that the data in `va_state_map` is already ordered by the `order` column.  This is done deliberately - it controls how the lines are connected.  If we change the order of the data, we will get a wacky result:
```{r}
unordered <- slice_sample(va_state_map, n = 734) #randomly reorder the rows

ggplot(unordered, aes(long, lat, group = group)) + 
   geom_path(color = "blue")
```

If you find that the data is not ordered properly (usually the result of merging datasets), just reorder `arrange()` by `group` and `order`:

```{r}
ggplot(arrange(unordered, group, order), aes (long, lat, group = group)) +
   geom_path(color = "blue")
```

You may have noticed that in each call we use the `group` aesthetic.  This tells ggplot how to segment the drawing of points.  This was necessary in our Virginia maps because there is non-contiguous territory.  Take a look at what happens if we didn't use the `group` aesthetic:

```{r}
ggplot(va_state_map, aes(long, lat)) +
   geom_path()
```

We get that funky line connecting the Delmarva peninsula to Northern Virginia.  If we were mapping an entirely contiguous territory, such as Kentucky, we could get away without the group aesthetic.  But probably just better to include it no matter what.  

Now, the `group` aesthetic is especially useful if we have map data with multiple regions/groups.  Take, for example, showing the states on a US map.  

```{r}
us <- ggplot(state_map, aes(long, lat, group = group))

us +
   geom_path()
```

We've been using `geom_path`, but you could also use `geom_polygon` which is just like `geom_path` but it allows a fill color:

```{r}
us +
   geom_polygon(fill = "white", color = "orange")
```

### Map Projections

You may have noticed that our maps don't look quite right.  Look at that razor sharp edge on the Northern border with Canada!  That ain't right.  We need to use a map projection to better display a non-flat Earth on a flat surface. Transformations (or spatial projections) can help show a map with better proportions.

```{r}
usmap = us + geom_polygon(fill="white", color="black") # initial map object

#- default coord_map(): mercator projection
usmap + coord_map() + ggtitle("Mercator")
```
```{r}
#- polyconic projection
usmap + coord_map("polyconic") + ggtitle("Polyconic")
```
```{r}
#- albers projection
usmap + coord_map("albers", lat0=29.5, lat1=45.4) + ggtitle("Albers")
```

A few things here: notice that Mercator is the default (blegh!) and that for the Albers projection, which is one we will frequently use, we pass it two latitude parameters, lat0 and lat1. In the example above, we are using their conventional values for a US map. 

### Adding Layers

Remember that ggplot is a layered graphics system.  So, we can layer additional data onto the map.  Let's start with just adding some cities to the map. The `us.cities` in the `maps` package contains lat, long, and population (2006 estimate) for 1005 of the largest cities in the US. Let’s add this to our US map.

```{r}
#- Create base map
base_map <-  ggplot(state_map, aes(x=long, y=lat)) +
   geom_polygon(aes(group=group), fill="white", color="lightgrey") +
   coord_map("albers", lat0=29.5, lat1=45.4)

base_map
```

Notice that the group aesthetic is moved to `geom_polygon()`. If this was left in `ggplot()`, then every other geom must use the group aesthetic.  Since `geom_point()` and `geom_text()` are going to use the `us.capitals` data, there is no group designation in the initial declaration.

```{r}
# get us city info
data(us.cities) # notice the `capital == 2` for state capitals; no idea why its 2 and not 1

# I only want capital cities for continental US (remove Alaska and Hawaii)
us_capitals <- us.cities %>% filter(capital==2, !country.etc %in% c("AK", "HI"))

# Make the map
base_map +
   geom_point(data=us_capitals, color="blue", size=2) +
   geom_text(data=us_capitals, aes(label=name),
             size=2.5, vjust=1, hjust=1)
```

Notice that `aes(x=long, y=lat)` is inherited from `base_map` for `geom_point()` and
`geom_text()`

### Choropleth Maps

Choropleth Maps are thematic maps in which areas are shaded or patterned in proportion to the measurement of the statistical variable being displayed on the map, such as population density or per-capita income. So we need to first begin by having data to display.  

The easiest way to do this is simply adding a column to the map data that contains the value we want to represent with a color.  So let's do something simple and create a column that has the length of the name of the county and map this to a fill color.

```{r}
county_data_map <- county_map %>%
   mutate(length=str_length(subregion))

head(county_data_map)
```

Let's map it:

```{r}
ggplot(county_data_map, aes(x=long, y=lat, group=group)) +
   geom_polygon(aes(fill = length), color='grey') + 
   ggtitle("Length of County Name")
```
Ok!  But those borders are way too over the top, and there's no projection.  Let's clean that up:

```{r}
ggplot(county_data_map, aes(x=long, y=lat, group=group)) + # use new data_map
   geom_polygon(aes(fill = length), color= NA) +
   geom_path(color = "grey", size = .1, alpha = .2) +
   coord_map("polyconic") +
   ggtitle("Length of County Name")
```

#### Getting actual data

Let's do a choropleth with some actual data.  Let's use gun violence data from Wikipedia.  The code below uses a web scraping library called `rvest` which you'll probably pick up at some point along the way, but we won't go into detail here.  

```{r}
#- get wiki table
library(rvest) # this is web scraping library
url <- 'https://en.wikipedia.org/wiki/Gun_violence_in_the_United_States_by_state'

guns <- read_html(url) %>% # get webpage html
   html_node("#mw-content-text > div.mw-parser-output > table:nth-child(14)") %>% # figured out the node using "inspect element" in Chrome
   html_table()

#- clean column names
colnames(guns) = c('state','pop', 'murders_manslaughter', 'murders', 'gun_murders',
                'hh_gun_ownership','murders_manslaughter_rate','murder_rate',
                "gun_murder_rate")

# convert data read in as characters to numerics
guns <- guns %>% 
   mutate(murders = as.numeric(murders), 
          gun_murders = as.numeric(gun_murders),
          murder_rate = as.numeric(murder_rate),
          gun_murder_rate = as.numeric(gun_murder_rate))

glimpse(guns)
```

Now we need to create a new column in our map data that takes our variable of interest (let's make it the proportion of murders that are commited by firearms.  There are a few NAs, so let's replace those with the mean for all available states.

```{r}
guns <- guns %>% 
   mutate(prop_gun_murders = gun_murders / murders, 
          prop_gun_murders = replace_na(prop_gun_murders, mean(prop_gun_murders, na.rm = T)),
          prop_gun_murders_decile = cut_number(prop_gun_murders, n=10))

ggplot(guns, aes(reorder(state, prop_gun_murders), prop_gun_murders)) +
   geom_bar(stat = "identity") +
   coord_flip()
```
Now that we have the variable of interest, we need to join that into the US state map data.  Take a look at the map data to see what approach our join needs to take.

```{r}
map_data(map = "state")
```

Notice that we have the state name in the `region` variable, but in all lower case.  So let's get that joined in:

```{r}
guns <- guns %>% 
   mutate(region = str_to_lower(state))

state_data <- left_join(map_data(map = "state"), guns)

glimpse(state_data)
```

Now we can create the choropleth maps using what we went over earlier:

```{r}
m1 <- ggplot(state_data, aes(x=long, y=lat, group=group)) + # use new data_map
   geom_polygon(aes(fill = prop_gun_murders), color= NA) +
   geom_path(color = "grey", size = .1, alpha = .2) +
   coord_map("polyconic") +
   labs(title = "Proportion of Murders that are Gun Related by State",
        caption = "No data available for AL, FL, IL - NAs replaced with mean ") +
   theme_void()

m1
```

Let's change the fill color scale with `scale_fill_` family of functions. We will use
`scale_fill_gradient2()` to make a diverging color scale that resembles traffic light colors with red as the highest value, yellow set to the mean, and green as the low.

```{r}
m1 +
   scale_fill_gradient2(low="green", mid='yellow', high="red",
                        midpoint=mean(guns$prop_gun_murders))
```
Here's an alternative map using the deciles variable and some different color mechanisms, specifically the colorBrewer diverging pallette that goes from Purple (high) to Orange (low):

```{r}
ggplot(state_data, aes(x=long, y=lat, group=group)) + # use new data_map
   geom_polygon(aes(fill = prop_gun_murders_decile), color= NA) +
   geom_path(color = "grey", size = .1, alpha = .2) +
   scale_fill_brewer(type = "div", palette = "PuOr", name = "") +
   guides(fill = guide_legend(reverse = T)) +
   coord_map("polyconic") +
   labs(title = "Proportion of Murders that are Gun Related by State",
        caption = "No data available for AL, FL, IL - NAs replaced with mean ") +
   theme_void()
```

### ggmap Package

```{r}
library(ggmap)
```

You can use the `ggmap` library to pull in tiled basemaps from different services, like Google Maps, OpenStreetMaps, or Stamen Maps.  

The default uses Google Maps, and in order to do this, you must use the `ggmap` package you must have a registered API key with Google.  To obtain an API key and enable services you have to visit [this website](https://cloud.google.com/maps-platform/).  You'll have to use a registered Google account, and use a credit card to become a verified user.  But note that account is free and your credit card should not be charged for low volume use.  Please pay attention to the details as you sign up to make sure you don't automatically end up registering for access that will cost you money!

Once registered, copy that API key.  To tell ggmap about your API key, use the `register_google` function with `key = INSERTYOURKEYHERE` as the parameter.  If you want to set it permanently then add the parameter `write = TRUE`, otherwise, you'll have to reregister each time you restart R.

**IMPORTANT SECURITY INFORMATION - MUST READ**
*This comes from the ggmap documentation*
>Users should be aware that the API key, a string of jarbled characters/numbers/symbols, is a PRIVATE key - it uniquely identifies and authenticates you to Google's services. If anyone gets your API key, they can use it to masquerade as you to Google and potentially use services that you have enabled. Since Google requires a valid credit card to use its online cloud services, this also means that anyone who obtains your key can potentially make charges to your card in the form of Google services. So be sure to not share your API key. To mitigate against users inadvertantly sharing their keys, by default ggmap never displays a user's key in messages displayed to the console.

>Users should also be aware that ggmap has no mechanism with which to safeguard the private key once registered with R. That is to say, once you register your API key, any function R will have access to it. As a consequence, ggmap will not know if another function, potentially from a compromised package, accesses the key and uploads it to a third party. For this reason, when using ggmap we recommend a heightened sense of security and self-awareness: only use trusted packages, do not save API keys in script files, routinely cycle keys (regenerate new keys and retire old ones), etc. Google offers features to help in securing your API key, including things like limiting queries using that key to a particular IP address, as well as guidance on security best practices. See https://cloud.google.com/docs/authentication/api-keys#securing_an_api_key for details.

The `ggmap` function `get_map` lets us grab a tiled base map by giving it a location and a zoom level.  It defaults to Google, but you can also designate `source = "osm"` for Open Street Map or `source = "stamen"` for Stamen maps.  For each source there are a variety of `maptype = ` options.

Below we obtain a map of the US at a zoom level of 3.  I've also designated the extreme lats and longs for the continental US so we can zoom in as tightly as possible on the map we generate.

Once we have the base map, we can visualize it just by calling `ggmap()` with the map object as the parameter.

```{r}
us <- get_map("united states", zoom=3)

left <- -124.7844079 # westernmost long in continental us
bottom <-   24.7433195 # southernmost lat in continental us
right <- -66.9513812 # easternmost long in continental us
top <-  49.3457868 # northernmost lat in continental us

ggmap(us)
```

Now we can take that basemap and just add to it, the same way we did earlier.  This will overlay a choropleth map on top of it.  Notice that we need to redesignate the data and aesthetic mappings in `geom_polygon` and `geom_path` because those are using different datasets and aesthetics than the ggmap.  

I've added a `scale_x_continuous` and `scale_y_continuous` so that we trim the map down to only the continental US.  Otherwise, it is essentially the same code call from the previous section on choropleth maps.

```{r}
ggmap(us) +
   geom_polygon(data = state_data, aes(x = long, y = lat, group = group, fill = prop_gun_murders_decile), color = NA, alpha = 0.6) +
   geom_path(data = state_data, aes(x = long, y = lat, group = group), color = "grey", size = .1, alpha = .2) +
   scale_x_continuous(limits = c(left, right)) +
   scale_y_continuous(limits = c(bottom, top)) +
   scale_fill_brewer(type = "div", palette = "PuOr", name = "") +
   guides(fill = guide_legend(reverse = T)) +
   labs(title = "Proportion of Murders that are Gun Related by State",
        caption = "No data available for AL, FL, IL - NAs replaced with mean ") +
   theme_void()
```

### Geocoding and Adding Points to a Map

There may be times you have a number of locations that you want to plot on a map.  For that, you'll usually have addresses (partial or full) and you need to have the appropriate latitude and longitude in order to actually display it on a map.  For that, you'll need to geocode. You can do this in `ggmap` but there is a better library for larger geocoding projects called `tidygeocoder`.  

In order to demonstrate this, we'll use a dataset of the hometowns of our PPOL 563 students that we obtained during our intro survey of the class.  First, we load the library and make a dataframe:

```{r}
library(tidygeocoder)

hometowns <- c("India","New Orleans, LA", "Chicago", "Greenville, SC","Los Angeles",
               "Central Pennsylvania", "New Delhi, India", "Syracuse, NY", "Shenzhen, China",
               "Bangalore, India", "China", "Grand Rapids, MI", "Nicaragua", "San Antonio, TX",
               "China", "Abu Dhabi, United Arab Emirates", "China", "Hinsdale, IL",
               "Waukesha, WI", "Chongqing, China", "Bucks County, PA", "Chicago",
               "Seattle", "Nashville", "Milford, Michigan", "Seattle", "Shanghai, China",
               "Miami", "Sao Paulo, Brazil", "Palo Alto", "Livermore, CA") %>% 
   as_tibble()

colnames(hometowns) <- "hometown"

hometowns
```

You'll note that we have a mix of location types here: some where just the country is listed, some city/state combinations, sometimes just a city, one that even just has a region ("Central Pennsylvania").  Fortunately, tidygeocoder elegantly handles all of those variations without any fussiness.  

To "forward-geocode" the data we call the `geocode()` function, passing it the data and telling it what column the addresses are in.  It usese the Open Street Map geocoding service here, but other services can be specified with the method argument. 

Only latitude and longitude are returned from the geocoding service in this example, but full_results = TRUE can be used to return all of the data from the geocoding service.

```{r}
lat_longs <- hometowns %>%
  geocode(hometown, method = 'osm', lat = latitude , long = longitude)

lat_longs
```

We can then take these points and place them on a world map.  Note that below we call ggplot's `borders` geom which is a quick and dirty way to draw a common map.  In their own words, the developers say you should use this for "crude reference lines, but you'll typically want something more sophisticated for communication graphics."

```{r}
ggplot(lat_longs, aes(longitude, latitude), color = "grey99") +
  borders("world") + geom_point() +
  theme_void()
```

To perform reverse geocoding (obtaining addresses from geographic coordinates), we can use the reverse_geocode() function. The arguments are similar to the geocode() function, but now we specify the input data columns with the lat and long arguments. The input dataset used here is the results of the geocoding query above.

The single line address is returned in a column named by the address argument and all columns from the geocoding service results are returned because full_results = TRUE. You'll see the wealth of data we get back from the service:

```{r}
reverse <- lat_longs %>%
  reverse_geocode(lat = latitude, long = longitude, method = 'osm',
                  address = address_found, full_results = TRUE)

glimpse(reverse)
```

### R's Built in Geo Data

R has a number of built in data sets that could be helpful with maps:

- `state.abb` - character vector of 2-letter abbreviations for the state names.
- `state.area` - numeric vector of state areas (in square miles).
- `state.center` - list with components named x and y giving the approximate geographic center of each state in negative longitude and latitude. Alaska and Hawaii are placed just off the West Coast.
- `state.division` - factor giving state divisions (New England, Middle Atlantic, South Atlantic, East South Central, West South Central, East North Central, West North Central, Mountain, and Pacific).
- `state.name` - character vector giving the full state names.
- `state.region` - factor giving the region (Northeast, South, North Central, West) that each state belongs to.
- `state.x77` - matrix with 50 rows and 8 columns giving the following statistics in the respective columns: population in 1975, per capita income 1974, illiteracy 1970, life expectancy in years (1969-71), murder per 100K 1976, % HS grads 1970, mean number of days w/min temp below freezing (1931-1960) in capital or large city, land area in square miles.

### Creating Custom Regions

### CDs and DMAs (using external shape files)

Shapefiles are a commonly supported file type for spatial data dating back to the early 1990s. Proprietary software for geographic information systems (GIS) such as ArcGIS pioneered this format and helps maintain its continued usage. A shapefile encodes points, lines, and polygons in geographic space, and is actually a set of files. Shapefiles appear with a .shp extension, sometimes with accompanying files ending in .dbf and .prj.

- .shp stores the geographic coordinates of the geographic features (e.g. country, state, county)
- .dbf stores data associated with the geographic features (e.g. unemployment rate, crime rates, percentage of votes cast for Donald Trump)
- .prj stores information about the projection of the coordinates in the shapefile

When importing a shapefile, you need to ensure all the files are in the same folder.  This is the complete shapefile. If any of these files are missing, you will get an error importing your shapefile.

The `st_read()` function turns a shapefile into a "Simple Features" dataframe that is easier to work with.  

```{r}
library(sf)

dma <- st_read("NatDMA.shp")
```

The geom_sf() function allows you to plot geospatial objects in any ggplot2 object. Since the  
x and y coordinates are implied by the geometry of the sf object, you don’t have to explicitly bind the x aesthetic to the longitudinal coordinate and the y aesthetic to the latitude. 

```{r}
m1 <- ggplot(dma) + 
   geom_sf() +
   coord_sf() +
   scale_x_continuous(limits = c(left, right)) +
   scale_y_continuous(limits = c(bottom, top))

# I was having issues rendering this live in the notebook. Saving it to an object and then as a PDF got this all working much faster.     

ggsave("map_demo.pdf")
```



### Tidycensus

```{r}
library(tidycensus)
census_api_key("YOUR API KEY GOES HERE")  # add the parameter install = TRUE if you want your API key stored in your R environment for future use

age10 <- get_decennial(geography = "state", 
                       variables = "P013001", 
                       year = 2010)

head(age10)
```


```{r}
age10 %>%
  ggplot(aes(x = value, y = reorder(NAME, value))) + 
  geom_point()
```


### Cartograms

### Statebins / Hexbins

The `statebins` library was built for easy creation of US visualizations.  It creates a new ggplot geom: `geom_statebins` which is easily incorporated into a ggplot series. 

Here's an example using categorical data:

```{r}
library(statebins)
library(socviz) # so we can easily get some recent election data

ggplot(election, aes(state = state, fill = winner)) +
   geom_statebins() +
   scale_fill_manual(values = c("blue", "red")) +
   theme_statebins()
```

And here's an example using continuous data:

```{r}
ggplot(election, aes(state = state, fill = pct_trump)) +
   geom_statebins() +
   scale_fill_distiller(palette = "Reds") +
   theme_statebins()
```




### Acknowledgements

- Many thanks to Michael Porter for his [geospatial tutorial](https://mdporter.github.io/ST597/lectures/13-spatial.pdf)
- The tidygeocoder package [help page](https://jessecambon.github.io/tidygeocoder/).